-- ============================================
-- 이벤트 응모 인원 제한 및 우선순위 기능 마이그레이션
-- 작성일: 2026-01-29
-- ============================================

-- 1. events 테이블에 max_entry_count 컬럼 추가
ALTER TABLE public.events ADD COLUMN IF NOT EXISTS max_entry_count integer DEFAULT NULL;

COMMENT ON COLUMN public.events.max_entry_count IS '최대 응모 인원 (NULL이면 제한 없음)';

-- 제약조건 추가 (0 이상이어야 함, NULL은 허용)
ALTER TABLE public.events ADD CONSTRAINT events_max_entry_count_check
  CHECK (max_entry_count IS NULL OR max_entry_count >= 1);


-- 2. 우선순위 사용자 테이블 생성
CREATE TABLE IF NOT EXISTS public.event_priority_users (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    source_event_id bigint NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    is_used boolean DEFAULT false,
    used_at timestamp with time zone DEFAULT NULL,
    used_event_id bigint REFERENCES public.events(id) ON DELETE SET NULL,
    UNIQUE (user_id, source_event_id)
);

COMMENT ON TABLE public.event_priority_users IS '이벤트 응모 우선순위 부여된 사용자 (응모 마감 후 시도한 사용자)';
COMMENT ON COLUMN public.event_priority_users.source_event_id IS '응모 실패한 원래 이벤트';
COMMENT ON COLUMN public.event_priority_users.is_used IS '우선순위 사용 여부';
COMMENT ON COLUMN public.event_priority_users.used_event_id IS '우선순위를 사용한 이벤트';

-- 인덱스 추가
CREATE INDEX IF NOT EXISTS idx_event_priority_users_user_id ON public.event_priority_users(user_id);
CREATE INDEX IF NOT EXISTS idx_event_priority_users_unused ON public.event_priority_users(user_id) WHERE is_used = false;


-- 3. enter_event 함수 수정 (응모 인원 제한 및 우선순위 기능 추가)
-- 반환 타입이 변경되므로 기존 함수를 먼저 DROP
DROP FUNCTION IF EXISTS public.enter_event(bigint);

CREATE OR REPLACE FUNCTION public.enter_event(p_event_id bigint)
RETURNS TABLE(success boolean, entry_number integer, message text, priority_granted boolean)
LANGUAGE plpgsql SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
    v_user_id bigint;
    v_event events%ROWTYPE;
    v_next_entry_number integer;
    v_existing_entry integer;
    v_current_entry_count bigint;
    v_has_priority boolean;
    v_priority_id bigint;
BEGIN
    -- 현재 사용자의 users.id 조회
    SELECT u.id INTO v_user_id
    FROM public.users u
    WHERE u.auth_user_id = auth.uid();

    IF v_user_id IS NULL THEN
        RETURN QUERY SELECT false, NULL::integer, '로그인이 필요합니다.'::text, false;
        RETURN;
    END IF;

    -- 이벤트별 Advisory Lock 획득 (동시 응모 시 race condition 방지)
    PERFORM pg_advisory_xact_lock(p_event_id);

    -- 이벤트 정보 조회
    SELECT * INTO v_event
    FROM public.events e
    WHERE e.id = p_event_id AND e.is_published = true;

    IF v_event IS NULL THEN
        RETURN QUERY SELECT false, NULL::integer, '이벤트를 찾을 수 없습니다.'::text, false;
        RETURN;
    END IF;

    -- 응모 기간 확인
    IF NOW() < v_event.entry_start_at THEN
        RETURN QUERY SELECT false, NULL::integer, '응모 기간이 아직 시작되지 않았습니다.'::text, false;
        RETURN;
    END IF;

    IF NOW() > v_event.entry_end_at THEN
        RETURN QUERY SELECT false, NULL::integer, '응모 기간이 종료되었습니다.'::text, false;
        RETURN;
    END IF;

    IF v_event.status != 'active' THEN
        RETURN QUERY SELECT false, NULL::integer, '현재 응모할 수 없는 이벤트입니다.'::text, false;
        RETURN;
    END IF;

    -- 이미 응모했는지 확인
    SELECT ee.entry_number INTO v_existing_entry
    FROM public.event_entries ee
    WHERE ee.event_id = p_event_id AND ee.user_id = v_user_id;

    IF v_existing_entry IS NOT NULL THEN
        RETURN QUERY SELECT false, v_existing_entry, '이미 응모하셨습니다.'::text, false;
        RETURN;
    END IF;

    -- 현재 응모자 수 확인
    SELECT COUNT(*) INTO v_current_entry_count
    FROM public.event_entries ee
    WHERE ee.event_id = p_event_id;

    -- 최대 응모 인원 확인 (max_entry_count가 설정되어 있는 경우)
    IF v_event.max_entry_count IS NOT NULL AND v_current_entry_count >= v_event.max_entry_count THEN
        -- 우선순위 보유 여부 확인
        SELECT epu.id INTO v_priority_id
        FROM public.event_priority_users epu
        WHERE epu.user_id = v_user_id AND epu.is_used = false
        LIMIT 1;

        IF v_priority_id IS NOT NULL THEN
            -- 우선순위 사용하여 응모 진행
            UPDATE public.event_priority_users
            SET is_used = true, used_at = NOW(), used_event_id = p_event_id
            WHERE id = v_priority_id;
        ELSE
            -- 우선순위가 없으면 우선순위 부여하고 응모 실패
            INSERT INTO public.event_priority_users (user_id, source_event_id)
            VALUES (v_user_id, p_event_id)
            ON CONFLICT (user_id, source_event_id) DO NOTHING;

            RETURN QUERY SELECT false, NULL::integer,
                '응모 인원이 마감되었습니다. 다음 이벤트에서 우선 응모 권한이 부여되었습니다!'::text, true;
            RETURN;
        END IF;
    END IF;

    -- 다음 응모 번호 계산 (Advisory Lock으로 보호됨)
    SELECT COALESCE(MAX(ee.entry_number), 0) + 1 INTO v_next_entry_number
    FROM public.event_entries ee
    WHERE ee.event_id = p_event_id;

    -- 응모 등록
    INSERT INTO public.event_entries (event_id, user_id, entry_number)
    VALUES (p_event_id, v_user_id, v_next_entry_number);

    RETURN QUERY SELECT true, v_next_entry_number, '응모가 완료되었습니다.'::text, false;
END;
$$;


-- 4. get_event_detail 함수 수정 (max_entry_count, has_priority 추가)
-- 반환 타입이 변경되므로 기존 함수를 먼저 DROP
DROP FUNCTION IF EXISTS public.get_event_detail(bigint);

CREATE OR REPLACE FUNCTION public.get_event_detail(p_event_id bigint)
RETURNS TABLE(
    id bigint,
    title text,
    description text,
    image_url text,
    image_urls text[],
    entry_start_at timestamp with time zone,
    entry_end_at timestamp with time zone,
    winner_announce_at timestamp with time zone,
    winner_count integer,
    max_entry_count integer,
    status text,
    entry_count bigint,
    user_entry_number integer,
    user_is_winner boolean,
    winner_numbers integer[],
    user_has_priority boolean,
    user_priority_count integer
)
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    v_auth_uid uuid := auth.uid();
    v_user_id bigint;
BEGIN
    -- auth.uid() (uuid) -> users.id (bigint) 매핑
    SELECT u.id INTO v_user_id
    FROM public.users u
    WHERE u.auth_user_id = v_auth_uid;

    RETURN QUERY
    SELECT
        e.id,
        e.title,
        e.description,
        e.image_url,
        e.image_urls,
        e.entry_start_at,
        e.entry_end_at,
        e.winner_announce_at,
        e.winner_count,
        e.max_entry_count,
        e.status,
        (SELECT COUNT(*) FROM event_entries WHERE event_id = e.id)::bigint as entry_count,
        (SELECT ee.entry_number FROM event_entries ee WHERE ee.event_id = e.id AND ee.user_id = v_user_id) as user_entry_number,
        (SELECT ee.is_winner FROM event_entries ee WHERE ee.event_id = e.id AND ee.user_id = v_user_id) as user_is_winner,
        (SELECT ARRAY_AGG(ee.entry_number ORDER BY ee.entry_number) FROM event_entries ee WHERE ee.event_id = e.id AND ee.is_winner = true) as winner_numbers,
        (SELECT EXISTS(SELECT 1 FROM event_priority_users epu WHERE epu.user_id = v_user_id AND epu.is_used = false)) as user_has_priority,
        (SELECT COUNT(*)::integer FROM event_priority_users epu WHERE epu.user_id = v_user_id AND epu.is_used = false) as user_priority_count
    FROM events e
    WHERE e.id = p_event_id;
END;
$$;


-- 5. get_events_list 함수 수정 (max_entry_count 추가)
-- 반환 타입이 변경되므로 기존 함수를 먼저 DROP
DROP FUNCTION IF EXISTS public.get_events_list();

CREATE OR REPLACE FUNCTION public.get_events_list()
RETURNS TABLE(
    id bigint,
    title text,
    description text,
    image_url text,
    image_urls text[],
    entry_start_at timestamp with time zone,
    entry_end_at timestamp with time zone,
    winner_announce_at timestamp with time zone,
    winner_count integer,
    max_entry_count integer,
    status text,
    entry_count bigint,
    user_entry_number integer
)
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    v_auth_uid uuid := auth.uid();
    v_user_id bigint;
BEGIN
    -- auth.uid() (uuid) -> users.id (bigint) 매핑
    SELECT u.id INTO v_user_id
    FROM public.users u
    WHERE u.auth_user_id = v_auth_uid;

    RETURN QUERY
    SELECT
        e.id,
        e.title,
        e.description,
        e.image_url,
        e.image_urls,
        e.entry_start_at,
        e.entry_end_at,
        e.winner_announce_at,
        e.winner_count,
        e.max_entry_count,
        e.status,
        (SELECT COUNT(*) FROM event_entries WHERE event_id = e.id)::bigint as entry_count,
        (SELECT ee.entry_number FROM event_entries ee WHERE ee.event_id = e.id AND ee.user_id = v_user_id) as user_entry_number
    FROM events e
    WHERE e.is_published = true
    ORDER BY e.entry_start_at DESC;
END;
$$;


-- 6. 사용자의 우선순위 목록 조회 함수
CREATE OR REPLACE FUNCTION public.get_my_event_priorities()
RETURNS TABLE(
    priority_id bigint,
    created_at timestamp with time zone,
    source_event_id bigint,
    source_event_title text,
    is_used boolean,
    used_at timestamp with time zone,
    used_event_id bigint,
    used_event_title text
)
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    v_user_id bigint;
BEGIN
    -- 현재 사용자의 users.id 조회
    SELECT u.id INTO v_user_id
    FROM public.users u
    WHERE u.auth_user_id = auth.uid();

    IF v_user_id IS NULL THEN
        RETURN;
    END IF;

    RETURN QUERY
    SELECT
        epu.id as priority_id,
        epu.created_at,
        epu.source_event_id,
        se.title as source_event_title,
        epu.is_used,
        epu.used_at,
        epu.used_event_id,
        ue.title as used_event_title
    FROM public.event_priority_users epu
    LEFT JOIN public.events se ON se.id = epu.source_event_id
    LEFT JOIN public.events ue ON ue.id = epu.used_event_id
    WHERE epu.user_id = v_user_id
    ORDER BY epu.created_at DESC;
END;
$$;
